// Code generated by protoc-gen-gogo.
// source: health.proto
// DO NOT EDIT!

package types

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import strings "strings"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Command struct {
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptorHealth, []int{0} }

type Check struct {
	ID          string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Protocol    string   `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Address     string   `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	Port        int64    `protobuf:"varint,4,opt,name=port,proto3" json:"port,omitempty"`
	Command     *Command `protobuf:"bytes,5,opt,name=command" json:"command,omitempty"`
	Path        string   `protobuf:"bytes,6,opt,name=path,proto3" json:"path,omitempty"`
	MaxFailures int64    `protobuf:"varint,7,opt,name=maxFailures,proto3" json:"maxFailures,omitempty"`
	Interval    int64    `protobuf:"varint,8,opt,name=Interval,proto3" json:"Interval,omitempty"`
	Timeout     int64    `protobuf:"varint,9,opt,name=Timeout,proto3" json:"Timeout,omitempty"`
	TaskID      string   `protobuf:"bytes,10,opt,name=taskId,proto3" json:"taskId,omitempty"`
	AppID       string   `protobuf:"bytes,11,opt,name=appId,proto3" json:"appId,omitempty"`
}

func (m *Check) Reset()                    { *m = Check{} }
func (m *Check) String() string            { return proto.CompactTextString(m) }
func (*Check) ProtoMessage()               {}
func (*Check) Descriptor() ([]byte, []int) { return fileDescriptorHealth, []int{1} }

type HealthCheck struct {
	ID                     string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Protocol               string   `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Address                string   `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	Port                   int64    `protobuf:"varint,5,opt,name=port,proto3" json:"port,omitempty"`
	PortIndex              int64    `protobuf:"varint,6,opt,name=portIndex,proto3" json:"portIndex,omitempty"`
	Command                *Command `protobuf:"bytes,7,opt,name=command" json:"command,omitempty"`
	Path                   string   `protobuf:"bytes,8,opt,name=path,proto3" json:"path,omitempty"`
	MaxConsecutiveFailures int64    `protobuf:"varint,9,opt,name=maxConsecutiveFailures,proto3" json:"maxConsecutiveFailures,omitempty"`
	GracePeriodSeconds     int64    `protobuf:"varint,10,opt,name=gracePeriodSeconds,proto3" json:"gracePeriodSeconds,omitempty"`
	IntervalSeconds        int64    `protobuf:"varint,11,opt,name=intervalSeconds,proto3" json:"intervalSeconds,omitempty"`
	TimeoutSeconds         int64    `protobuf:"varint,12,opt,name=timeoutSeconds,proto3" json:"timeoutSeconds,omitempty"`
	TaskID                 string   `protobuf:"bytes,13,opt,name=taskId,proto3" json:"taskId,omitempty"`
	AppID                  string   `protobuf:"bytes,14,opt,name=appId,proto3" json:"appId,omitempty"`
}

func (m *HealthCheck) Reset()                    { *m = HealthCheck{} }
func (m *HealthCheck) String() string            { return proto.CompactTextString(m) }
func (*HealthCheck) ProtoMessage()               {}
func (*HealthCheck) Descriptor() ([]byte, []int) { return fileDescriptorHealth, []int{2} }

func init() {
	proto.RegisterType((*Command)(nil), "types.Command")
	proto.RegisterType((*Check)(nil), "types.Check")
	proto.RegisterType((*HealthCheck)(nil), "types.HealthCheck")
}
func (this *Command) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Command)
	if !ok {
		that2, ok := that.(Command)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Command")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Command but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Command but is not nil && this == nil")
	}
	if this.Value != that1.Value {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *Command) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Command)
	if !ok {
		that2, ok := that.(Command)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *Check) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Check)
	if !ok {
		that2, ok := that.(Check)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Check")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Check but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Check but is not nil && this == nil")
	}
	if this.ID != that1.ID {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if this.Protocol != that1.Protocol {
		return fmt.Errorf("Protocol this(%v) Not Equal that(%v)", this.Protocol, that1.Protocol)
	}
	if this.Address != that1.Address {
		return fmt.Errorf("Address this(%v) Not Equal that(%v)", this.Address, that1.Address)
	}
	if this.Port != that1.Port {
		return fmt.Errorf("Port this(%v) Not Equal that(%v)", this.Port, that1.Port)
	}
	if !this.Command.Equal(that1.Command) {
		return fmt.Errorf("Command this(%v) Not Equal that(%v)", this.Command, that1.Command)
	}
	if this.Path != that1.Path {
		return fmt.Errorf("Path this(%v) Not Equal that(%v)", this.Path, that1.Path)
	}
	if this.MaxFailures != that1.MaxFailures {
		return fmt.Errorf("MaxFailures this(%v) Not Equal that(%v)", this.MaxFailures, that1.MaxFailures)
	}
	if this.Interval != that1.Interval {
		return fmt.Errorf("Interval this(%v) Not Equal that(%v)", this.Interval, that1.Interval)
	}
	if this.Timeout != that1.Timeout {
		return fmt.Errorf("Timeout this(%v) Not Equal that(%v)", this.Timeout, that1.Timeout)
	}
	if this.TaskID != that1.TaskID {
		return fmt.Errorf("TaskID this(%v) Not Equal that(%v)", this.TaskID, that1.TaskID)
	}
	if this.AppID != that1.AppID {
		return fmt.Errorf("AppID this(%v) Not Equal that(%v)", this.AppID, that1.AppID)
	}
	return nil
}
func (this *Check) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Check)
	if !ok {
		that2, ok := that.(Check)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if !this.Command.Equal(that1.Command) {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if this.MaxFailures != that1.MaxFailures {
		return false
	}
	if this.Interval != that1.Interval {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if this.TaskID != that1.TaskID {
		return false
	}
	if this.AppID != that1.AppID {
		return false
	}
	return true
}
func (this *HealthCheck) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*HealthCheck)
	if !ok {
		that2, ok := that.(HealthCheck)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *HealthCheck")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *HealthCheck but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *HealthCheck but is not nil && this == nil")
	}
	if this.ID != that1.ID {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if this.Protocol != that1.Protocol {
		return fmt.Errorf("Protocol this(%v) Not Equal that(%v)", this.Protocol, that1.Protocol)
	}
	if this.Address != that1.Address {
		return fmt.Errorf("Address this(%v) Not Equal that(%v)", this.Address, that1.Address)
	}
	if this.Port != that1.Port {
		return fmt.Errorf("Port this(%v) Not Equal that(%v)", this.Port, that1.Port)
	}
	if this.PortIndex != that1.PortIndex {
		return fmt.Errorf("PortIndex this(%v) Not Equal that(%v)", this.PortIndex, that1.PortIndex)
	}
	if !this.Command.Equal(that1.Command) {
		return fmt.Errorf("Command this(%v) Not Equal that(%v)", this.Command, that1.Command)
	}
	if this.Path != that1.Path {
		return fmt.Errorf("Path this(%v) Not Equal that(%v)", this.Path, that1.Path)
	}
	if this.MaxConsecutiveFailures != that1.MaxConsecutiveFailures {
		return fmt.Errorf("MaxConsecutiveFailures this(%v) Not Equal that(%v)", this.MaxConsecutiveFailures, that1.MaxConsecutiveFailures)
	}
	if this.GracePeriodSeconds != that1.GracePeriodSeconds {
		return fmt.Errorf("GracePeriodSeconds this(%v) Not Equal that(%v)", this.GracePeriodSeconds, that1.GracePeriodSeconds)
	}
	if this.IntervalSeconds != that1.IntervalSeconds {
		return fmt.Errorf("IntervalSeconds this(%v) Not Equal that(%v)", this.IntervalSeconds, that1.IntervalSeconds)
	}
	if this.TimeoutSeconds != that1.TimeoutSeconds {
		return fmt.Errorf("TimeoutSeconds this(%v) Not Equal that(%v)", this.TimeoutSeconds, that1.TimeoutSeconds)
	}
	if this.TaskID != that1.TaskID {
		return fmt.Errorf("TaskID this(%v) Not Equal that(%v)", this.TaskID, that1.TaskID)
	}
	if this.AppID != that1.AppID {
		return fmt.Errorf("AppID this(%v) Not Equal that(%v)", this.AppID, that1.AppID)
	}
	return nil
}
func (this *HealthCheck) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HealthCheck)
	if !ok {
		that2, ok := that.(HealthCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.PortIndex != that1.PortIndex {
		return false
	}
	if !this.Command.Equal(that1.Command) {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if this.MaxConsecutiveFailures != that1.MaxConsecutiveFailures {
		return false
	}
	if this.GracePeriodSeconds != that1.GracePeriodSeconds {
		return false
	}
	if this.IntervalSeconds != that1.IntervalSeconds {
		return false
	}
	if this.TimeoutSeconds != that1.TimeoutSeconds {
		return false
	}
	if this.TaskID != that1.TaskID {
		return false
	}
	if this.AppID != that1.AppID {
		return false
	}
	return true
}
func (this *Command) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&types.Command{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Check) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&types.Check{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	if this.Command != nil {
		s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	}
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	s = append(s, "MaxFailures: "+fmt.Sprintf("%#v", this.MaxFailures)+",\n")
	s = append(s, "Interval: "+fmt.Sprintf("%#v", this.Interval)+",\n")
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "TaskID: "+fmt.Sprintf("%#v", this.TaskID)+",\n")
	s = append(s, "AppID: "+fmt.Sprintf("%#v", this.AppID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HealthCheck) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&types.HealthCheck{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "PortIndex: "+fmt.Sprintf("%#v", this.PortIndex)+",\n")
	if this.Command != nil {
		s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	}
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	s = append(s, "MaxConsecutiveFailures: "+fmt.Sprintf("%#v", this.MaxConsecutiveFailures)+",\n")
	s = append(s, "GracePeriodSeconds: "+fmt.Sprintf("%#v", this.GracePeriodSeconds)+",\n")
	s = append(s, "IntervalSeconds: "+fmt.Sprintf("%#v", this.IntervalSeconds)+",\n")
	s = append(s, "TimeoutSeconds: "+fmt.Sprintf("%#v", this.TimeoutSeconds)+",\n")
	s = append(s, "TaskID: "+fmt.Sprintf("%#v", this.TaskID)+",\n")
	s = append(s, "AppID: "+fmt.Sprintf("%#v", this.AppID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringHealth(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringHealth(m github_com_gogo_protobuf_proto.Message) string {
	e := github_com_gogo_protobuf_proto.GetUnsafeExtensionsMap(m)
	if e == nil {
		return "nil"
	}
	s := "proto.NewUnsafeXXX_InternalExtensions(map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "})"
	return s
}
func (m *Command) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Command) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHealth(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *Check) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Check) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHealth(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHealth(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHealth(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Port != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHealth(dAtA, i, uint64(m.Port))
	}
	if m.Command != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHealth(dAtA, i, uint64(m.Command.Size()))
		n1, err := m.Command.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintHealth(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.MaxFailures != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintHealth(dAtA, i, uint64(m.MaxFailures))
	}
	if m.Interval != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintHealth(dAtA, i, uint64(m.Interval))
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintHealth(dAtA, i, uint64(m.Timeout))
	}
	if len(m.TaskID) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintHealth(dAtA, i, uint64(len(m.TaskID)))
		i += copy(dAtA[i:], m.TaskID)
	}
	if len(m.AppID) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintHealth(dAtA, i, uint64(len(m.AppID)))
		i += copy(dAtA[i:], m.AppID)
	}
	return i, nil
}

func (m *HealthCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHealth(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHealth(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHealth(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Port != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHealth(dAtA, i, uint64(m.Port))
	}
	if m.PortIndex != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHealth(dAtA, i, uint64(m.PortIndex))
	}
	if m.Command != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintHealth(dAtA, i, uint64(m.Command.Size()))
		n2, err := m.Command.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintHealth(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.MaxConsecutiveFailures != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintHealth(dAtA, i, uint64(m.MaxConsecutiveFailures))
	}
	if m.GracePeriodSeconds != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintHealth(dAtA, i, uint64(m.GracePeriodSeconds))
	}
	if m.IntervalSeconds != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintHealth(dAtA, i, uint64(m.IntervalSeconds))
	}
	if m.TimeoutSeconds != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintHealth(dAtA, i, uint64(m.TimeoutSeconds))
	}
	if len(m.TaskID) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintHealth(dAtA, i, uint64(len(m.TaskID)))
		i += copy(dAtA[i:], m.TaskID)
	}
	if len(m.AppID) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintHealth(dAtA, i, uint64(len(m.AppID)))
		i += copy(dAtA[i:], m.AppID)
	}
	return i, nil
}

func encodeFixed64Health(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Health(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintHealth(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedCommand(r randyHealth, easy bool) *Command {
	this := &Command{}
	this.Value = string(randStringHealth(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheck(r randyHealth, easy bool) *Check {
	this := &Check{}
	this.ID = string(randStringHealth(r))
	this.Protocol = string(randStringHealth(r))
	this.Address = string(randStringHealth(r))
	this.Port = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Port *= -1
	}
	if r.Intn(10) != 0 {
		this.Command = NewPopulatedCommand(r, easy)
	}
	this.Path = string(randStringHealth(r))
	this.MaxFailures = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.MaxFailures *= -1
	}
	this.Interval = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Interval *= -1
	}
	this.Timeout = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Timeout *= -1
	}
	this.TaskID = string(randStringHealth(r))
	this.AppID = string(randStringHealth(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHealthCheck(r randyHealth, easy bool) *HealthCheck {
	this := &HealthCheck{}
	this.ID = string(randStringHealth(r))
	this.Protocol = string(randStringHealth(r))
	this.Address = string(randStringHealth(r))
	this.Port = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Port *= -1
	}
	this.PortIndex = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.PortIndex *= -1
	}
	if r.Intn(10) != 0 {
		this.Command = NewPopulatedCommand(r, easy)
	}
	this.Path = string(randStringHealth(r))
	this.MaxConsecutiveFailures = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.MaxConsecutiveFailures *= -1
	}
	this.GracePeriodSeconds = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.GracePeriodSeconds *= -1
	}
	this.IntervalSeconds = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.IntervalSeconds *= -1
	}
	this.TimeoutSeconds = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.TimeoutSeconds *= -1
	}
	this.TaskID = string(randStringHealth(r))
	this.AppID = string(randStringHealth(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyHealth interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneHealth(r randyHealth) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringHealth(r randyHealth) string {
	v1 := r.Intn(100)
	tmps := make([]rune, v1)
	for i := 0; i < v1; i++ {
		tmps[i] = randUTF8RuneHealth(r)
	}
	return string(tmps)
}
func randUnrecognizedHealth(r randyHealth, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldHealth(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldHealth(dAtA []byte, r randyHealth, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateHealth(dAtA, uint64(key))
		v2 := r.Int63()
		if r.Intn(2) == 0 {
			v2 *= -1
		}
		dAtA = encodeVarintPopulateHealth(dAtA, uint64(v2))
	case 1:
		dAtA = encodeVarintPopulateHealth(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateHealth(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateHealth(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateHealth(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateHealth(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *Command) Size() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovHealth(uint64(l))
	}
	return n
}

func (m *Check) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovHealth(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovHealth(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovHealth(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovHealth(uint64(m.Port))
	}
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovHealth(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovHealth(uint64(l))
	}
	if m.MaxFailures != 0 {
		n += 1 + sovHealth(uint64(m.MaxFailures))
	}
	if m.Interval != 0 {
		n += 1 + sovHealth(uint64(m.Interval))
	}
	if m.Timeout != 0 {
		n += 1 + sovHealth(uint64(m.Timeout))
	}
	l = len(m.TaskID)
	if l > 0 {
		n += 1 + l + sovHealth(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovHealth(uint64(l))
	}
	return n
}

func (m *HealthCheck) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovHealth(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovHealth(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovHealth(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovHealth(uint64(m.Port))
	}
	if m.PortIndex != 0 {
		n += 1 + sovHealth(uint64(m.PortIndex))
	}
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovHealth(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovHealth(uint64(l))
	}
	if m.MaxConsecutiveFailures != 0 {
		n += 1 + sovHealth(uint64(m.MaxConsecutiveFailures))
	}
	if m.GracePeriodSeconds != 0 {
		n += 1 + sovHealth(uint64(m.GracePeriodSeconds))
	}
	if m.IntervalSeconds != 0 {
		n += 1 + sovHealth(uint64(m.IntervalSeconds))
	}
	if m.TimeoutSeconds != 0 {
		n += 1 + sovHealth(uint64(m.TimeoutSeconds))
	}
	l = len(m.TaskID)
	if l > 0 {
		n += 1 + l + sovHealth(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovHealth(uint64(l))
	}
	return n
}

func sovHealth(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozHealth(x uint64) (n int) {
	return sovHealth(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Command) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHealth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHealth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHealth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Check) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHealth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Check: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Check: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &Command{}
			}
			if err := m.Command.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFailures", wireType)
			}
			m.MaxFailures = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFailures |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHealth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHealth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHealth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortIndex", wireType)
			}
			m.PortIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortIndex |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &Command{}
			}
			if err := m.Command.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConsecutiveFailures", wireType)
			}
			m.MaxConsecutiveFailures = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConsecutiveFailures |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GracePeriodSeconds", wireType)
			}
			m.GracePeriodSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GracePeriodSeconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalSeconds", wireType)
			}
			m.IntervalSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntervalSeconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutSeconds", wireType)
			}
			m.TimeoutSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutSeconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHealth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHealth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHealth(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHealth
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHealth
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthHealth
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowHealth
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipHealth(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthHealth = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHealth   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("health.proto", fileDescriptorHealth) }

var fileDescriptorHealth = []byte{
	// 456 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x51, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0x25, 0x71, 0x6d, 0x27, 0xe3, 0x12, 0xa4, 0x15, 0xaa, 0x56, 0x15, 0x4a, 0xaa, 0x08, 0xa1,
	0x5e, 0x70, 0x25, 0x90, 0xb8, 0xd3, 0x44, 0x88, 0xdc, 0xd0, 0xd2, 0x1f, 0xd8, 0x78, 0x97, 0xd8,
	0xaa, 0xed, 0xb5, 0xec, 0x75, 0x55, 0xfe, 0x88, 0x4f, 0xe0, 0x03, 0x38, 0x54, 0x9c, 0xf8, 0x02,
	0xd4, 0xf6, 0x0b, 0x38, 0x72, 0x64, 0x3c, 0x8e, 0x83, 0x55, 0x15, 0xc1, 0x85, 0xc3, 0xc8, 0x3b,
	0xef, 0xbd, 0x5d, 0xcf, 0xbc, 0x07, 0xfb, 0xb1, 0x96, 0xa9, 0x8d, 0xc3, 0xa2, 0x34, 0xd6, 0x30,
	0xd7, 0x7e, 0x2c, 0x74, 0x75, 0xf8, 0x7c, 0x93, 0xd8, 0xb8, 0x5e, 0x87, 0x91, 0xc9, 0x4e, 0x36,
	0x66, 0x63, 0x4e, 0x88, 0x5d, 0xd7, 0x1f, 0xa8, 0xa3, 0x86, 0x4e, 0xed, 0xad, 0xf9, 0x0c, 0xfc,
	0x85, 0xc9, 0x32, 0x99, 0x2b, 0xf6, 0x18, 0xdc, 0x0b, 0x99, 0xd6, 0x9a, 0x0f, 0x8e, 0x06, 0xc7,
	0x63, 0xd1, 0x36, 0xf3, 0x2f, 0x43, 0x70, 0x17, 0xb1, 0x8e, 0xce, 0xd9, 0x01, 0x0c, 0x13, 0xd5,
	0x92, 0xa7, 0xde, 0xed, 0xf7, 0xd9, 0x70, 0xb5, 0x14, 0x88, 0xb0, 0x43, 0x18, 0xd1, 0x5b, 0x91,
	0x49, 0xf9, 0x90, 0xae, 0xee, 0x7a, 0xc6, 0xc1, 0x97, 0x4a, 0x95, 0xba, 0xaa, 0xb8, 0x43, 0x54,
	0xd7, 0x32, 0x06, 0x7b, 0x85, 0x29, 0x2d, 0xdf, 0x43, 0xd8, 0x11, 0x74, 0x66, 0xc7, 0xe0, 0x47,
	0xed, 0x30, 0xdc, 0x45, 0x38, 0x78, 0x31, 0x09, 0x69, 0xa9, 0x70, 0x3b, 0xa2, 0xe8, 0x68, 0xba,
	0x2d, 0x6d, 0xcc, 0x3d, 0x7a, 0x94, 0xce, 0xec, 0x08, 0x82, 0x4c, 0x5e, 0xbe, 0x91, 0x49, 0x5a,
	0xe3, 0x1f, 0xb8, 0x4f, 0x0f, 0xf7, 0xa1, 0x66, 0xd2, 0x55, 0x6e, 0x75, 0x89, 0x9b, 0xf1, 0x11,
	0xd1, 0xbb, 0xbe, 0x99, 0xf4, 0x2c, 0xc9, 0xb4, 0xa9, 0x2d, 0x1f, 0x13, 0xd5, 0xb5, 0x6c, 0x0e,
	0x9e, 0x95, 0xd5, 0xf9, 0x4a, 0x71, 0xa0, 0xdd, 0x01, 0x77, 0xf7, 0xce, 0x1a, 0x64, 0x29, 0xb6,
	0x0c, 0x9b, 0x81, 0x2b, 0x8b, 0x02, 0x25, 0x01, 0x49, 0xc6, 0x28, 0x71, 0x5f, 0x23, 0xb0, 0x14,
	0x2d, 0x3e, 0xff, 0xea, 0x40, 0xf0, 0x96, 0xe2, 0xfa, 0x9f, 0x66, 0xba, 0x3d, 0x33, 0x9f, 0xc0,
	0xb8, 0xf9, 0xae, 0x72, 0xa5, 0x2f, 0xc9, 0x27, 0x47, 0xfc, 0x06, 0xfa, 0x56, 0xfb, 0xff, 0x66,
	0xf5, 0xa8, 0x67, 0xf5, 0x2b, 0x38, 0x40, 0x5f, 0x17, 0x26, 0xaf, 0x74, 0x54, 0xdb, 0xe4, 0x42,
	0xef, 0x5c, 0x6f, 0xbd, 0xfb, 0x03, 0xcb, 0x42, 0x60, 0x9b, 0x52, 0x46, 0xfa, 0x9d, 0x2e, 0x13,
	0xa3, 0xde, 0xeb, 0xc8, 0xe4, 0xaa, 0x22, 0x5b, 0x1d, 0x71, 0x0f, 0x83, 0x53, 0x3e, 0x4a, 0xb6,
	0x01, 0x75, 0xe2, 0x80, 0xc4, 0x77, 0x61, 0xf6, 0x0c, 0x26, 0xb6, 0xcd, 0xab, 0x13, 0xee, 0x93,
	0xf0, 0x0e, 0xda, 0x0b, 0xf3, 0xe1, 0xdf, 0xc3, 0x9c, 0xdc, 0x1f, 0xe6, 0xe9, 0xd3, 0xab, 0x9b,
	0xe9, 0x83, 0xeb, 0x9b, 0xe9, 0xe0, 0x07, 0xd6, 0x4f, 0xac, 0x4f, 0xb7, 0xd3, 0xc1, 0x67, 0xac,
	0x2b, 0xac, 0x6f, 0x58, 0xd7, 0x58, 0x6b, 0x8f, 0x82, 0x7b, 0xf9, 0x2b, 0x00, 0x00, 0xff, 0xff,
	0xa2, 0x01, 0xfd, 0xf9, 0xa7, 0x03, 0x00, 0x00,
}
